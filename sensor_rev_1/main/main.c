// Copyright 2015 Silicon Laboratories, Inc.

#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include "stack/include/ember.h"

#include "hal/hal.h"
#include "phy/phy.h"
#include "serial/serial.h"
#include "connect-bookkeeping.h"
#include "connect-callbacks.h"

// Our entry point is typically main(), except in simulation.
// In simulation we don't include the cortexm3-specific headers.
#if defined(EMBER_TEST)
  #define MAIN nodeMain
  #if defined(EMBER_AF_API_DIAGNOSTIC_CORTEXM3)
    #undef EMBER_AF_API_DIAGNOSTIC_CORTEXM3
  #endif // EMBER_AF_API_DIAGNOSTIC_CORTEXM3
#else
  #define MAIN main
#endif // EMBER_TEST

// If serial functionality is enabled, we will initialize the serial ports
// during startup.  This has to happen after the HAL and gateway, if applicable,
// are initialized.
#ifdef EMBER_AF_API_SERIAL
  #include EMBER_AF_API_SERIAL
// TODO: SERIAL_INIT() should be auto-generated by AppBuilder
  #define SERIAL_INIT()                                                        \
  do {                                                                         \
    emberSerialInit((uint8_t)COM_USART2, (SerialBaudRate)BAUD_115200, (SerialParity)PARITY_NONE, 1); \
  } while(FALSE)
#else
  #define SERIAL_INIT()
  #define emberSerialPrintfLine(...)
#endif
 

// If printing is enabled, we will print some diagnostic information about the
// most recent reset and also during runtime.  On some platforms, extended
// diagnostic information is available.
#if defined(EMBER_AF_API_SERIAL) && defined(EMBER_AF_PRINT_ENABLE)
  #if defined(EMBER_AF_API_DIAGNOSTIC_CORTEXM3)
    #include EMBER_AF_API_DIAGNOSTIC_CORTEXM3
  #endif
  static void printResetInformation(void);
  #define PRINT_RESET_INFORMATION printResetInformation
  #define emberAfGuaranteedPrint(...) \
    emberSerialGuaranteedPrintf(COM_USART2, __VA_ARGS__)
  #define emberAfGuaranteedPrintln(...)                     \
    do {                                                    \
      emberSerialGuaranteedPrintf(COM_USART2, __VA_ARGS__); \
      emberSerialGuaranteedPrintf(COM_USART2, "\r\n");      \
    } while (FALSE)
#else
  #define PRINT_RESET_INFORMATION()
  #define emberAfGuaranteedPrint(...)
  #define emberAfGuaranteedPrintln(...)
#endif

EmberTaskId emAppTask;
extern const EmberEventData emAppEvents[];

#ifdef EMBER_AF_PLUGIN_FREE_RTOS
extern void emberPluginRtosInitAndRunConnectTask(void);
#endif

//////ADDED_START////////
#define SENSOR_SINK_SECURITY_KEY    {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\
                                     0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\
                                     0xAA, 0xAA, 0xAA, 0xAA}

static EmberKeyData securityKey = SENSOR_SINK_SECURITY_KEY;
//////ADDED_END//////////

void initAndRunMainLoop(void)
{
  EmberEventControl dataReportControl;
  EmberStatus status;
  int counter_reset = 0;
  emberTaskEnableIdling(true);

  emAppTask = emberTaskInit(emAppEvents);

  // Initialize the radio and the stack.  If this fails, we have to assert
  // because something is wrong.
  status = emberInit();
  emberSerialPrintfLine(COM_USART2, "Inititialization: 0x%x", status);	//ember success;0x00 so emberinit worked
  assert(status == EMBER_SUCCESS);


  emberAfInit();
  emberAfMainInitCallback();       //emberNetworkInit() called here

  emberResetNetworkState(); /////////////////leave network to join coordinator

  EmberNetworkStatus net_status;
  EmberNetworkParameters parameters;

  emberSetSecurityKey(&securityKey);

  MEMSET(&parameters, 0, sizeof(EmberNetworkParameters));
  parameters.radioTxPower = 0;
  parameters.radioChannel = 1;
  parameters.panId = 0x01FF;

  halStackSeedRandom(halCommonGetInt32uMillisecondTick());

  while (TRUE) {
    // Let the stack or EZSP layer run periodic tasks.
    emberTick();
    // Let the application and plugins run periodic tasks.

    emberAfMainTickCallback();
    emberAfTick();
    emberEventControlSetActive(dataReportControl);

    net_status = emberNetworkState();
    //emberResetNetworkState();
    //emberJoinNetwork(EMBER_STAR_END_DEVICE, &parameters);
    /*
    if(!emberStackIsUp()){
    	emberAfGuaranteedPrintln("stack wasn't up");
    	emberJoinNetwork(EMBER_STAR_END_DEVICE, &parameters);
    }
	*/
    //emberAfGuaranteedPrintln("net_status is: %d", net_status);
    if(counter_reset == 10000){
    	emberResetNetworkState();
    	counter_reset = 0;
    }
    else{
    	counter_reset++;
    }
    if (net_status == EMBER_NO_NETWORK){
        //emberPermitJoining(0xFF);
    	//emberResetNetworkState();
    	emberAfGuaranteedPrintln("Network has been reset");
    	emberJoinNetwork(EMBER_STAR_END_DEVICE, &parameters);
    }



    emberRunTask(emAppTask);
  }
}

int MAIN(MAIN_FUNCTION_PARAMETERS) 
{
  // Initialize the HAL and enable interrupts.
  halInit();

  INTERRUPTS_ON();

  SERIAL_INIT();

  PRINT_RESET_INFORMATION();

#ifdef EMBER_AF_PLUGIN_FREE_RTOS
  emberPluginRtosInitAndRunConnectTask();
#else
  initAndRunMainLoop();
#endif

  return 0;
}

void emberStackStatusHandler(EmberStatus status)
{
  emberAfStackStatusCallback(status);
  emberAfStackStatus(status);
}

void emberChildJoinHandler(EmberNodeType nodeType,
                           EmberNodeId nodeId)
{
  emberAfChildJoinCallback(nodeType, nodeId);
  emberAfChildJoin(nodeType, nodeId);
}

void emberIncomingMessageHandler(EmberIncomingMessage *message)
{
  emberAfIncomingMessageCallback(message);
  emberAfIncomingMessage(message);
}

void emberMessageSentHandler(EmberStatus status, EmberOutgoingMessage *message)
{
  emberAfMessageSentCallback(status, message);
  emberAfMessageSent(status, message);
}

void emberIncomingBeaconHandler(EmberPanId panId,
                                EmberNodeId nodeId,
                                uint8_t payloadLength,
                                uint8_t *payload)
{
  emberAfIncomingBeaconCallback(panId, nodeId, payloadLength, payload);
  emberAfIncomingBeacon(panId, nodeId, payloadLength, payload);

}

void emberActiveScanCompleteHandler(void)
{
  emberAfActiveScanCompleteCallback();
  emberAfActiveScanComplete();
}

void emberEnergyScanCompleteHandler(int8_t mean,
                                    int8_t min,
                                    int8_t max,
                                    uint16_t variance)
{
  emberAfEnergyScanCompleteCallback(mean, min, max, variance);
  emberAfEnergyScanComplete(mean, min, max, variance);
}

void emberStackIsrHandler(void)
{
  // TODO: for now we do not expose this to the application.

  emberAfStackIsr();
}

#ifdef EMBER_AF_PRINT_ENABLE

static void printResetInformation(void)
{
  // Information about the most recent reset is printed during startup to aid
  // in debugging.
  emberAfGuaranteedPrintln("Reset info: 0x%x (%p)",
                           halGetResetInfo(),
                           halGetResetString());

#if defined(EMBER_AF_API_DIAGNOSTIC_CORTEXM3)
  emberAfGuaranteedPrintln("Extended reset info: 0x%2x (%p)",
                           halGetExtendedResetInfo(),
                           halGetExtendedResetString());
  if (halResetWasCrash()) {
    halPrintCrashSummary(COM_USART2);
    halPrintCrashDetails(COM_USART2);
    halPrintCrashData(COM_USART2);
  }
#endif // EMBER_AF_API_DIAGNOSTIC_CORTEXM3
}

#endif // EMBER_AF_PRINT_ENABLE
